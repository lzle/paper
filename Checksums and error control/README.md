# Checksums and error control
Chen Luo · Michael J. Carey    19 Jul 2019

## 目录

- [Abstract](#abstract)


## 5.1 Fletcher Checksum

Fletcher 校验和（Fletcher checksum）［6］［11］最初是为 OSI 通信模型的传输层（第 4 层）而设计的。该方法在本质上是一种“和的和（sum of sums）”的计算技术，所有加法运算均在模 255 的意义下进行。（但需要注意的是，255 并不是一个素数！）因此，我们计算如下过程。

$$
\begin{align*}
s1 &= (s1 + d_i) \bmod 255 \\
s2 &= (s2 + s1) \bmod 255
\end{align*}
$$

如果校验和位于消息末尾（这是通常的情况），则将两个校验字节设置为
$B_1 = s1 - s2$ 和 $B\_2 = -2s\_1 + s\_2$，
从而使包括这两个校验字节在内的整体校验和为零。与许多校验和方法不同，对正确传输的检测方式略有差异：当 $s1 = 0 \text{ or } s2 = 0$ 中任意一个成立时，结果即被认为是正确的；只有在两个累加和均非零的情况下，才会报告发生错误。

> 注："包括这两个校验字节在内的整体校验和为零"表示包含校验数据在内最终 $s1$ 或 $s2$ 任意一个为 0。

> $n_1 s_1 = (s_1 + B_1) = 2s_1 - s_2$, $n_1 s_2 = (s_2 + n_1 s_1) = 2s_1 \implies n_2 s_1 = (n_1 s_1 + B_2) = (2s_1 - s_2 - (-2s_1 + s_2)) = 0$, $n_2 s_2 = (n_1 s_2 + n_2 s_1) = (2s_1 + 0) = 2s_1$


如果校验和字节位于一个长度为 $L$ 个八位字节（octet）的消息中的第 $n$ 和第 $n+1$ 个位置（消息位置编号为$0$ ... $L-1$），则

$$
\begin{align*}
b_n &= (L - n) \times s1 - s2 \\
b_{n+1} &= s2 - (L - n + 1) \times s1
\end{align*}
$$

> 注：上面公式最终计算结果 $s2 = 0$, $s2$ 是“带位置权重”的和。

下面给出了一个 Java 代码片段，用于根据包含 $nChar$ 个字符的数组 `c[]` 计算校验和。需要注意的是，这些字符应当限制为 ASCII 字符，或者至少其取值应 `< 256`。其中使用的 `while` 循环在功能上等价于带余除法（division with remainder），但在本场景下通常只需进行极少次数的修正，因此这种实现方式在性能上更为高效。

```java
int s1 = 0, s2 = 0; // initialise checksums
for (int i = 0; i < nChars; i++) // scan the characters
  {
  s1 += c[i]; // add in the character
  while (s1 >= 255) // reduce modulo 255
    s1 -= 255;
  s2 += s1; // get the sum of sums
  while (s2 >= 255) // modulo 255
    s2 -= 255;
  }
```

Fletcher 校验和被认为其差错检测能力几乎与下文所描述的 CRC-16 校验和同样强大，能够检测到：

* 所有单比特错误，
* 所有双比特错误，
* 长度不超过 16 的突发错误中除 `0.000019%` 之外的全部错误，以及长度更长的突发错误中除 `0.0015%` 之外的全部错误。


## 5.3 Cyclic Redundancy Checks

CRC 编码是最重要且应用最为广泛的差错检测码。它们特别适合在极高工作速度下以硬件方式实现，因此被用于大多数数据通信系统中。它们同样建立在模运算（modular arithmetic）的基础之上，但与前述示例相比，在方法和原理上引入了若干重要的变化。

1、“数系”从传统且熟悉的整数体系转变为**有限域（finite fields）**，具体而言是 **GF(2)**。所有算术运算均在 模 2 的意义下进行，如下文第 3 点所述。

2、比特被视为多项式中的系数。这使得有限域与多项式域中高度发展且功能强大的数学理论能够应用于差错控制编码理论，包括差错检测与差错纠正。

将比特向量表示为多项式的形式，还为那些通常包含大量零元素的比特向量提供了一种便捷的表示方法。在多项式中，仅对应于取值为 1 的项会出现，并且通过指数形式直观地给出了比特的位置。因此，这两种表示方式是等价的。

$$
100101 \Leftrightarrow x^5 + x^2 + 1
$$

同样

$$
100000111 \Leftrightarrow x^8 + x^2 + x + 1
$$

多项式变量在编码过程的大多数情况下实际上只是一个虚变量，并无太多实际意义。它可以被视为指数的一个“载体”。

整数中的数值算术运算被 GF(2) 有限域上的比特逻辑运算所取代。此时，加法与减法均等价于异或（Exclusive-OR, $\oplus$），而乘法等价于逻辑与（AND，∧）。（在这两种情况下，将比特视为数值，执行相应运算，并对结果取模 2）由于比特之间不存在进位传播，这一点立即消除了快速加法实现中的一个主要障碍。

实际上，这一变化意味着算术运算可以通过简单的逻辑操作非常容易且快速地完成。尽管在此并未进行深入展开，但这为在高速硬件中采用这些方法提供了强大的动机。

> 注：GF(2) 加法等价于异或（XOR），示例：0+0=0，0+1=1，1+0=1，1+1=0;

> 注：GF(2) 减法等价于加法（XOR），示例：1-1=0，1-0=1，0-1=1，0-0=0;

> 注：GF(2) 乘法等价于逻辑与（AND），示例：0×0=0，0×1=0，1×0=0，1×1=1

循环冗余校验（CRC）中最直观的操作是 **多项式除法**，如 Figure 3 所示。除去略有改变的减法规则外，其整体方法与传统的长除法完全相同。除数是一个固定不变的多项式，并且被归一化，保证其最高有效位（最高次项系数）为 1。（在实际中，它的最低有效位（常数项）也为 1，因此得到的多项式形式为 $x^N + \dots + 1$。从技术上讲，除数多项式 $g(x)$ 是首一（monic）多项式。）由于减法中不存在进位传播，当余数的最高位为 1 时，即可从部分余数中减去除数；不需要像整数除法中那样进行“试减”或对溢出进行补偿。此示例中被除数的形式及其书写方式是经过刻意选择的，以便与 CRC 计算中多项式除法的使用相匹配 $\text{CRCs}(i(x) = x^6 + x^3 + 1$ 且 $g(x) = x^3 + x + 1$)

<div align=center><img src="images/cec_fig_3.png" width=500></div>

> 注：首一多项式基础定义，一个多项式中，次数最高的项（最高次项）的系数为 1，这样的多项式就是首一多项式。

当将多项式用于校验和生成时，发送的数据构成一维比特流，其中较早出现的比特对应于多项式中的高次幂。在数据传输及其正确性校验过程中，会涉及多个多项式。

**信息多项式 $i(x)$**：信息多项式表示由用户提供并发送的数据（通常包括首部、地址以及其他传输控制信息）。信息多项式通常在不作任何修改的情况下直接传输。

**生成多项式 $g(x)$**：将信息多项式除以生成多项式，并将该除法所得的余数作为校验和附加到数据中。通常在进行除法之前，先在 $i(x)$ 后附加与 $g(x)$ 次数相对应数量的零。

**码字多项式 $c(x)$**：将除法得到的校验和附加到信息多项式之后，形成码字多项式，该多项式即为实际传输的内容。

**差错多项式 $e(x)$**：在传输过程中，码字多项式 $c(x)$ 中的一个或多个比特可能被破坏。这些发生错误的位置可以表示为一个多项式，即差错多项式 $e(x)$。

**接收码字 $v(x)$**：这是在传输过程中发生破坏之后所接收到的数据。由于 $e(x)$ 标记了传输数据中被破坏的比特，因此显然有 $v = c \oplus e$（假定按项进行异或运算），或等价地 $v(x) = c(x) + e(x)$。

更具体地说，若 $r$ 为 $g(x)$ 的次数

1、在 $i(x)$ 的低阶端附加 $r$ 个零，形成 $x^r i(x)$。

2、计算 $x^r i(x)$ mod $g(x)$，即将 $x^r i(x)$ 除以 $g(x)$ 所得到的余数。

3、将该余数附加到 $i(x)$ 后，形成 $c(x)$，即实际传输的码字。因此，传输的码字为：

$$
c(x) = x^r i(x) - \left(x^r i(x) \mod g(x)\right)
$$

始终是 $g(x)$ 的倍数。（步骤 1 确保了 $i(x)$ 的全部内容都能被 $g(x)$ 处理，同时也为余数的写入预留了空间）

4、接收时，计算

$$
\begin{align*}
r(x) &= v(x) \mod g(x) \\
&= e(x) \mod g(x) + c(x) \mod g(x) \\
&= e(x) \mod g(x) \text{, as } c(x) \mod g(x) \equiv 0 \text{ by construction}
\end{align*}
$$

只有当且仅当 $e(x)$ 是 $g(x)$ 的倍数时，错误才不会被检测到。因此，生成多项式 $g(x)$ 的设计决定了差错检测的能力，而其设计又取决于 $g(x)$ 与 $e(x)$ 的关系。

* 如果发生单比特错误，则差错多项式为 $e(x) = x^i$，其中 $i$ 表示出错的比特位置。若 $g(x)$ 包含两个或更多项，它将永远无法整除 $e(x)$，因此所有单比特错误都能够被检测到。

* 如果存在两个孤立的单比特错误，则差错多项式为 $e(x) = x^i + x^j$，或者当 $i > j$ 时，可写作 $e(x) = x^j (x^{i-j} + 1)$。若 $g(x)$ 不可被 $x$ 整除，则若 $g(x)$ 不整除 $x^k + 1$（对于所有 $k$ 直到最大消息长度），所有双比特错误都将被检测到。可以通过计算机搜索找到合适的 $g(x)$；例如 $x^{15} + x^{14} + 1$ 不整除任何 $k < 32768$ 的 $x^k + 1$。

* 如果发生奇数个比特错误，则差错多项式 $e(x)$ 中也含有奇数个项。由于没有含奇数项的多项式可以被 $(x+1)$ 整除，因此我们令 $g(x)$ 包含 $(x+1)$ 作为因子，以便检测所有奇数个错误。

* 具有 $r$ 个校验比特的多项式码能够检测长度 ≤ $r$ 的突发错误。长度为 $k$ 的突发错误可以表示为 $x^i (x^{k-1} + \dots + 1)$。如果 $g(x)$ 含有常数项，则其不含 $x^i$ 项，因此当 $x^{k-1} + \dots + 1$ 的次数小于 $g(x)$ 的次数时，余数不可能为零。

* 当突发错误长度为 $r+1$ 时，余数 $r(x)$ 仅在突发错误与 $g(x)$ 完全相同时才为零。如果所有比特组合出现的概率相等，则中间的 $r-1$ 个比特全部匹配的概率为 $1/2^{r-1}$。

* 对于更长的突发错误，未检测到错误的概率为 $1/2^r$。

在 CRC 码的描述中，许多内容实际上源于在差错纠正中使用多项式技术，这些技术在 Hamming 码的基础上得到了发展和改进。块差错纠正码的关键区别在于，将 $v(x)$ 除以 $g(x)$ 所得到的余数被称为综合值（syndrome） $s(x)$，可用于确定差错向量 $e(x)$，从而纠正任何错误。尽管操作机制类似，但 $g(x)$ 的设计与前述用于差错检测的设计有很大不同。


## 5.4 Examples of CRC polynomials

作为一个初步观察，多项式 (x^8 + 1) 在由 8 位字符组成的消息上生成了一种简单的纵向奇偶校验，对其他字符长度的情况亦然。（在 (g(x)) 中包含两个比特，它们在数据流中对应于相邻两个数据字符中的相同位。这种“窗口”效应的结果是：将每个数据字符中的各个位通过异或运算（Exclusive-OR）累积到一个整体奇偶校验字符中的对应位上。）

一些标准的差错检测多项式包括：

|               |                                                                                         |
|---------------|-----------------------------------------------------------------------------------------|
| CRC-12        | $x^{12} + x^{11} + x^3 + x + 1$                                                         |
| CRC-16        | $x^{16} + x^{15} + x^2 + 1$                                                             |
| CRC-CCITT     | $x^{16} + x^{12} + x^5 + 1$                                                             |
| IEEE 802      | $x^{32} + x^{26} + x^{23} + x^{22} + x^{16} + x^{12} + x^{11} + x^{10} + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1$ |
| ATM HEC       | $x^8 + x^2 + x + 1$                                                                     |
| ATM AAL3/4    | $x^{10} + x^9 + x^5 + x^4 + x + 1$                                                      |


CRC-12 在一些较早的银行系统和航班预订系统中用于 6 位字符编码。

16 位 CRC（在北美主要使用 CRC-16，在欧洲使用 CRC-CCITT）能够检测所有长度不超过 16 位的突发错误、所有包含奇数个比特的错误，以及 99.998% 的长度为 18 位或以上的突发错误。

> 注：r 位 CRC（常数项为 1）能 100% 检测长度≤r 的突发错误，因此 16 位 CRC 对长度 1~16 位的突发错误实现无漏检。

“ATM HEC” 是用于 ATM（异步传输模式，Asynchronous Transfer Mode）信元的首部差错控制码。它覆盖前面的 4 个字节，能够纠正所有单比特错误，并检测多种多比特错误。

“ATM AAL3/4” 用于在 ATM 适配层 3 和 4 中验证每个 ATM 信元的用户数据。

“IEEE 802” 校验和除 IEEE 802.x 标准之外，还被许多通信系统采用，包括光纤通道（Fibre Channel）和 ATM AAL-5。

在某些情况下，校验的具体细节会有所变化。例如，在 X.25 帧中使用的是 CRC-CCITT 多项式。

* 移位寄存器初始时被预置为全 1；

* 校验位在随信息比特移出时被取反；

* 接收端在计算时将校验字段一并包含在内；

* 计算结果必须为 1111 0000 1011 1000。

尽管 IEEE 802 生成多项式在许多通信系统中得到了非常广泛的应用，但其具体使用方式存在若干变体。
在 802.3 竞争总线（以太网，Ethernet）中，

* 数据的前 32 位先进行取反；

* 将包括首部和用户数据在内的整个帧除以生成多项式；

* 帧校验序列（FCS）比特在随信息比特移出时被取反；

* 接收端检查由此前接收数据生成的 FCS 是否与接收到的 FCS 相一致。

而在 802.5 令牌总线（Token Bus）中，

* 用于校验和的 32 位寄存器初始化为全 1；

* 将包括首部和用户数据在内的整个帧除以生成多项式；

* 校验比特在随信息比特移出时被取反；

* 接收端在计算时将校验字段一并包含在内；

* 计算结果（包括接收到的校验和）必须为 $x^{31} + x^{30} + x^{26} + x^{25} + x^{24} + x^{18} + x^{15} + x^{14} + x^{12} + x^{11} + x^{10} + x^8 + x^6 + x^5 + x^4 + x^3 + x + 1$ ，
  或以二进制表示为：1100 0111 0000 0100 1101 1101 0111 1011。

代码示例：

```golang
package main

import (
	"fmt"
)

// crc16CCITT 计算 CRC-16/CCITT（多项式 x^16 + x^12 + x^5 + 1）
func crc16CCITT(data []byte) uint16 {
	var crc uint16 = 0xFFFF // 初始值
	const poly uint16 = 0x1021

	for _, b := range data {
		crc ^= uint16(b) << 8
		for i := 0; i < 8; i++ {
			if crc&0x8000 != 0 {
				crc = (crc << 1) ^ poly
			} else {
				crc <<= 1
			}
		}
	}
	return crc
}

func main() {
	data := []byte("HELLO")
	crc := crc16CCITT(data)
	fmt.Printf("CRC-16/CCITT of %q: 0x%04X\n", data, crc)
}
```

## References

[Checksums and error control](https://pages.cs.wisc.edu/~remzi/OSTEP/Citations/checksums-03.pdf)